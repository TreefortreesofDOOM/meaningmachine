'use strict';

var axios = require('axios');
var urlSearchParamsSerializer = require('@seamapi/url-search-params-serializer');
var axiosBetterStacktrace = require('axios-better-stacktrace');
var axiosRetry = require('axios-retry');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var axios__default = /*#__PURE__*/_interopDefault(axios);
var axiosBetterStacktrace__default = /*#__PURE__*/_interopDefault(axiosBetterStacktrace);
var axiosRetry__default = /*#__PURE__*/_interopDefault(axiosRetry);

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/lib/lts-version.ts
var seamApiLtsVersion = "1.0.0";

// src/lib/version.ts
var seamapiJavascriptHttpVersion = "0.0.0";
var version_default = seamapiJavascriptHttpVersion;

// src/lib/seam/connect/parse-options.ts
var defaultEndpoint = "https://connect.getseam.com";
var sdkHeaders = {
  "seam-sdk-name": "seamapi/javascript-http",
  "seam-sdk-version": version_default,
  "seam-lts-version": seamApiLtsVersion
};
var parseOptions = (apiKeyOrOptions) => {
  const options = getNormalizedOptions(apiKeyOrOptions);
  if (isSeamHttpOptionsWithClient(options))
    return options;
  if (isSeamHttpMultiWorkspaceOptionsWithClient(options))
    return options;
  return {
    ...options,
    axiosOptions: {
      baseURL: options.endpoint ?? getEndpointFromEnv() ?? defaultEndpoint,
      withCredentials: isSeamHttpOptionsWithClientSessionToken(options),
      ...options.axiosOptions,
      headers: {
        ...getAuthHeaders(options),
        ...options.axiosOptions?.headers,
        ...sdkHeaders
      }
    },
    axiosRetryOptions: {
      ...options.axiosRetryOptions
    }
  };
};
var getNormalizedOptions = (apiKeyOrOptions) => {
  const options = typeof apiKeyOrOptions === "string" ? { apiKey: apiKeyOrOptions } : apiKeyOrOptions;
  const requestOptions = {
    waitForActionAttempt: options.waitForActionAttempt ?? false
  };
  if (isSeamHttpOptionsWithClient(options)) {
    return {
      ...options,
      ...requestOptions
    };
  }
  const apiKey = "apiKey" in options ? options.apiKey : getApiKeyFromEnv(options);
  return {
    ...options,
    ...apiKey != null ? { apiKey } : {},
    ...requestOptions
  };
};
var getApiKeyFromEnv = (options) => {
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    return null;
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    return null;
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    return null;
  }
  return globalThis.process?.env?.SEAM_API_KEY;
};
var getEndpointFromEnv = () => {
  if (globalThis.process?.env?.SEAM_API_URL != null) {
    console.warn(
      "Using the SEAM_API_URL environment variable is deprecated. Support will be remove in a later major version. Use SEAM_ENDPOINT instead."
    );
  }
  if (globalThis.process?.env?.SEAM_API_URL != null && globalThis.process?.env?.SEAM_ENDPOINT != null) {
    console.warn(
      "Detected both the SEAM_API_URL and SEAM_ENDPOINT environment variables. Using SEAM_ENDPOINT."
    );
  }
  return globalThis.process?.env?.SEAM_ENDPOINT ?? globalThis.process?.env?.SEAM_API_URL;
};
var limitToSeamHttpRequestOptions = (options) => {
  return Object.keys(options).filter(isSeamHttpRequestOption).reduce(
    (obj, key) => ({
      ...obj,
      [key]: options[key]
    }),
    {}
  );
};
var isSeamHttpRequestOption = (key) => {
  const keys = {
    waitForActionAttempt: true
  };
  return Object.keys(keys).includes(key);
};

// src/lib/seam/connect/options.ts
var isSeamHttpMultiWorkspaceOptionsWithClient = (options) => isSeamHttpOptionsWithClient(options);
var isSeamHttpOptionsWithClient = (options) => {
  if (!("client" in options))
    return false;
  if (options.client == null)
    return false;
  const keys = Object.keys(options).filter((k) => k !== "client");
  if (keys.filter((k) => !isSeamHttpRequestOption(k)).length > 0) {
    throw new SeamHttpInvalidOptionsError(
      `The client option cannot be used with any other option, but received: ${keys.join(
        ", "
      )}`
    );
  }
  return true;
};
var isSeamHttpOptionsWithApiKey = (options) => {
  if (!("apiKey" in options))
    return false;
  if (options.apiKey == null)
    return false;
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the apiKey option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the apiKey option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the apiKey option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithClientSessionToken = (options) => {
  if (!("clientSessionToken" in options))
    return false;
  if (options.clientSessionToken == null)
    return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the clientSessionToken option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the clientSessionToken option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the clientSessionToken option"
    );
  }
  return true;
};
var isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken = (options) => {
  if (!("consoleSessionToken" in options))
    return false;
  if (options.consoleSessionToken == null)
    return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the consoleSessionToken option"
    );
  }
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the consoleSessionToken option"
    );
  }
  if ("personalAccessToken" in options && options.personalAccessToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The personalAccessToken option cannot be used with the consoleSessionToken option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithConsoleSessionToken = (options) => {
  if (!isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(options)) {
    return false;
  }
  if (!("workspaceId" in options) || options.workspaceId == null) {
    throw new SeamHttpInvalidOptionsError(
      "Must pass a workspaceId when using a consoleSessionToken"
    );
  }
  return true;
};
var isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken = (options) => {
  if (!("personalAccessToken" in options))
    return false;
  if (options.personalAccessToken == null)
    return false;
  if ("apiKey" in options && options.apiKey != null) {
    throw new SeamHttpInvalidOptionsError(
      "The apiKey option cannot be used with the personalAccessToken option"
    );
  }
  if ("clientSessionToken" in options && options.clientSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The clientSessionToken option cannot be used with the personalAccessToken option"
    );
  }
  if ("consoleSessionToken" in options && options.consoleSessionToken != null) {
    throw new SeamHttpInvalidOptionsError(
      "The consoleSessionToken option cannot be used with the personalAccessToken option"
    );
  }
  return true;
};
var isSeamHttpOptionsWithPersonalAccessToken = (options) => {
  if (!isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(options)) {
    return false;
  }
  if (!("workspaceId" in options) || options.workspaceId == null) {
    throw new SeamHttpInvalidOptionsError(
      "Must pass a workspaceId when using a personalAccessToken"
    );
  }
  return true;
};
var SeamHttpInvalidOptionsError = class extends Error {
  constructor(message) {
    super(`SeamHttp received invalid options: ${message}`);
    this.name = this.constructor.name;
  }
};
var SeamHttpMultiWorkspaceInvalidOptionsError = class extends SeamHttpInvalidOptionsError {
};

// src/lib/seam/connect/token.ts
var tokenPrefix = "seam_";
var accessTokenPrefix = "seam_at";
var jwtPrefix = "ey";
var clientSessionTokenPrefix = "seam_cst";
var publishableKeyTokenPrefix = "seam_pk";
var isAccessToken = (token) => token.startsWith(accessTokenPrefix);
var isJwt = (token) => token.startsWith(jwtPrefix);
var isSeamToken = (token) => token.startsWith(tokenPrefix);
var isApiKey = (token) => !isClientSessionToken(token) && !isJwt(token) && !isAccessToken(token) && !isPublishableKey(token) && isSeamToken(token);
var isClientSessionToken = (token) => token.startsWith(clientSessionTokenPrefix);
var isPublishableKey = (token) => token.startsWith(publishableKeyTokenPrefix);
var isConsoleSessionToken = (token) => isJwt(token);
var isPersonalAccessToken = (token) => isAccessToken(token);

// src/lib/seam/connect/auth.ts
var getAuthHeaders = (options) => {
  if ("publishableKey" in options) {
    return getAuthHeadersForPublishableKey(options.publishableKey);
  }
  if (isSeamHttpOptionsWithApiKey(options)) {
    return getAuthHeadersForApiKey(options);
  }
  if (isSeamHttpOptionsWithClientSessionToken(options)) {
    return getAuthHeadersForClientSessionToken(options);
  }
  if (isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(options) || isSeamHttpOptionsWithConsoleSessionToken(options)) {
    return getAuthHeadersForConsoleSessionToken(options);
  }
  if (isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(options) || isSeamHttpOptionsWithPersonalAccessToken(options)) {
    return getAuthHeadersForPersonalAccessToken(options);
  }
  throw new SeamHttpInvalidOptionsError(
    [
      "Must specify",
      "an apiKey,",
      "clientSessionToken,",
      "publishableKey,",
      "consoleSessionToken",
      "or personalAccessToken.",
      "Attempted reading configuration from the environment, but the environment variable SEAM_API_KEY is not set."
    ].join(" ")
  );
};
var getAuthHeadersForApiKey = ({
  apiKey
}) => {
  if (isClientSessionToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as an apiKey"
    );
  }
  if (isJwt(apiKey)) {
    throw new SeamHttpInvalidTokenError("A JWT cannot be used as an apiKey");
  }
  if (isAccessToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as an apiKey"
    );
  }
  if (isPublishableKey(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as an apiKey"
    );
  }
  if (!isSeamToken(apiKey)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid apiKey format, expected token to start with ${tokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${apiKey}`
  };
};
var getAuthHeadersForClientSessionToken = ({
  clientSessionToken
}) => {
  if (isJwt(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a clientSessionToken"
    );
  }
  if (isAccessToken(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a clientSessionToken"
    );
  }
  if (isPublishableKey(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a clientSessionToken"
    );
  }
  if (!isClientSessionToken(clientSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid clientSessionToken format, expected token to start with ${clientSessionTokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${clientSessionToken}`,
    "client-session-token": clientSessionToken
  };
};
var getAuthHeadersForConsoleSessionToken = ({
  consoleSessionToken,
  ...options
}) => {
  const workspaceId = "workspaceId" in options ? options.workspaceId : void 0;
  if (isAccessToken(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a consoleSessionToken"
    );
  }
  if (isClientSessionToken(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as a consoleSessionToken"
    );
  }
  if (isPublishableKey(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a consoleSessionToken"
    );
  }
  if (!isJwt(consoleSessionToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid consoleSessionToken format, expected a JWT which starts with ${jwtPrefix}`
    );
  }
  return {
    authorization: `Bearer ${consoleSessionToken}`,
    ...workspaceId != null ? { "seam-workspace": workspaceId } : {}
  };
};
var getAuthHeadersForPersonalAccessToken = ({
  personalAccessToken,
  ...options
}) => {
  const workspaceId = "workspaceId" in options ? options.workspaceId : void 0;
  if (isJwt(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a personalAccessToken"
    );
  }
  if (isClientSessionToken(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token cannot be used as a personalAccessToken"
    );
  }
  if (isPublishableKey(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      "A Publishable Key cannot be used as a personalAccessToken"
    );
  }
  if (!isAccessToken(personalAccessToken)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid personalAccessToken format, expected token to start with ${accessTokenPrefix}`
    );
  }
  return {
    authorization: `Bearer ${personalAccessToken}`,
    ...workspaceId != null ? { "seam-workspace": workspaceId } : {}
  };
};
var getAuthHeadersForPublishableKey = (publishableKey) => {
  if (isJwt(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "A JWT cannot be used as a publishableKey"
    );
  }
  if (isAccessToken(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "An Access Token cannot be used as a publishableKey"
    );
  }
  if (isClientSessionToken(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      "A Client Session Token Key cannot be used as a publishableKey"
    );
  }
  if (!isPublishableKey(publishableKey)) {
    throw new SeamHttpInvalidTokenError(
      `Unknown or invalid publishableKey format, expected token to start with ${publishableKeyTokenPrefix}`
    );
  }
  return {
    "seam-publishable-key": publishableKey
  };
};
var SeamHttpInvalidTokenError = class extends Error {
  constructor(message) {
    super(`SeamHttp received an invalid token: ${message}`);
    this.name = this.constructor.name;
  }
};
var warnOnInsecureuserIdentifierKey = (userIdentifierKey) => {
  if (isEmail(userIdentifierKey)) {
    console.warn(
      ...[
        "Using an email for the userIdentifierKey is insecure and may return an error in the future!",
        "This is insecure because an email is common knowledge or easily guessed.",
        "Use something with sufficient entropy known only to the owner of the client session.",
        "For help choosing a user identifier key see",
        "https://docs.seam.co/latest/seam-components/overview/get-started-with-client-side-components#3-select-a-user-identifier-key"
      ]
    );
  }
};
var isEmail = (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);

// src/lib/seam/connect/seam-http-error.ts
var SeamHttpApiError = class extends Error {
  constructor(error, statusCode, requestId) {
    const { type, message, data } = error;
    super(message);
    this.name = this.constructor.name;
    this.code = type;
    this.statusCode = statusCode;
    this.requestId = requestId;
    if (data != null)
      this.data = data;
  }
};
var isSeamHttpApiError = (error) => {
  return error instanceof SeamHttpApiError;
};
var SeamHttpUnauthorizedError = class extends SeamHttpApiError {
  constructor(requestId) {
    const type = "unauthorized";
    const status = 401;
    super({ type, message: "Unauthorized" }, status, requestId);
    this.name = this.constructor.name;
    this.code = type;
    this.statusCode = status;
    this.requestId = requestId;
  }
};
var isSeamHttpUnauthorizedError = (error) => {
  return error instanceof SeamHttpUnauthorizedError;
};
var SeamHttpInvalidInputError = class extends SeamHttpApiError {
  constructor(error, statusCode, requestId) {
    super(error, statusCode, requestId);
    this.name = this.constructor.name;
    this.code = "invalid_input";
  }
};
var isSeamHttpInvalidInputError = (error) => {
  return error instanceof SeamHttpInvalidInputError;
};

// src/lib/seam/connect/error-interceptor.ts
var errorInterceptor = async (err) => {
  if (!axios.isAxiosError(err))
    throw err;
  const { response } = err;
  const status = response?.status;
  const requestId = getRequestId(err);
  if (status == null)
    throw err;
  if (status === 401) {
    throw new SeamHttpUnauthorizedError(requestId);
  }
  if (!isApiErrorResponse(response))
    throw err;
  const { type } = response.data.error;
  const args = [response.data.error, status, requestId];
  if (type === "invalid_input")
    throw new SeamHttpInvalidInputError(...args);
  throw new SeamHttpApiError(...args);
};
var isApiErrorResponse = (response) => {
  if (response == null)
    return false;
  const { headers, data } = response;
  if (headers == null)
    return false;
  const contentType = headers["Content-Type"];
  if (typeof contentType === "string" && !contentType.startsWith("application/json")) {
    return false;
  }
  if (typeof data === "object" && data != null) {
    return "error" in data && typeof data.error === "object" && data.error != null && "type" in data.error && typeof data.error.type === "string";
  }
  return false;
};
var getRequestId = (err) => {
  const headers = err.response?.headers;
  if (headers == null)
    return "";
  const requestId = headers["seam-request-id"];
  if (requestId == null)
    return "";
  return requestId;
};
var createClient = (options) => {
  const client = axios__default.default.create({
    paramsSerializer: urlSearchParamsSerializer.serializeUrlSearchParams,
    ...options.axiosOptions
  });
  axiosBetterStacktrace__default.default(axios__default.default);
  axiosRetry__default.default(client, {
    retries: 2,
    retryDelay: axiosRetry.exponentialDelay,
    ...options.axiosRetryOptions
  });
  client.interceptors.response.use(void 0, errorInterceptor);
  return client;
};

// src/lib/seam/connect/openapi.ts
var getOpenapiSchema = async (endpoint = defaultEndpoint) => {
  const client = createClient({
    axiosOptions: {
      baseURL: endpoint,
      headers: sdkHeaders
    }
  });
  const { data } = await client.get("/openapi.json");
  return data;
};

// src/lib/seam/connect/resolve-action-attempt.ts
var resolveActionAttempt = async (actionAttempt, actionAttempts, { timeout = 5e3, pollingInterval = 500 }) => {
  let timeoutRef;
  const timeoutPromise = new Promise(
    (_resolve, reject) => {
      timeoutRef = globalThis.setTimeout(() => {
        reject(new SeamActionAttemptTimeoutError(actionAttempt, timeout));
      }, timeout);
    }
  );
  try {
    return await Promise.race([
      pollActionAttempt(actionAttempt, actionAttempts, { pollingInterval }),
      timeoutPromise
    ]);
  } finally {
    if (timeoutRef != null)
      globalThis.clearTimeout(timeoutRef);
  }
};
var pollActionAttempt = async (actionAttempt, actionAttempts, options) => {
  if (isSuccessfulActionAttempt(actionAttempt)) {
    return actionAttempt;
  }
  if (isFailedActionAttempt(actionAttempt)) {
    throw new SeamActionAttemptFailedError(actionAttempt);
  }
  await new Promise((resolve) => setTimeout(resolve, options.pollingInterval));
  const nextActionAttempt = await actionAttempts.get({
    action_attempt_id: actionAttempt.action_attempt_id
  });
  return await pollActionAttempt(
    nextActionAttempt,
    actionAttempts,
    options
  );
};
var isSeamActionAttemptError = (error) => {
  return error instanceof SeamActionAttemptError;
};
var SeamActionAttemptError = class extends Error {
  constructor(message, actionAttempt) {
    super(message);
    this.name = this.constructor.name;
    this.actionAttempt = actionAttempt;
  }
};
var isSeamActionAttemptFailedError = (error) => {
  return error instanceof SeamActionAttemptFailedError;
};
var SeamActionAttemptFailedError = class extends SeamActionAttemptError {
  constructor(actionAttempt) {
    super(actionAttempt.error.message, actionAttempt);
    this.name = this.constructor.name;
    this.code = actionAttempt.error.type;
  }
};
var isSeamActionAttemptTimeoutError = (error) => {
  return error instanceof SeamActionAttemptTimeoutError;
};
var SeamActionAttemptTimeoutError = class extends SeamActionAttemptError {
  constructor(actionAttempt, timeout) {
    super(
      `Timed out waiting for action action attempt after ${timeout}ms`,
      actionAttempt
    );
    this.name = this.constructor.name;
  }
};
var isSuccessfulActionAttempt = (actionAttempt) => actionAttempt.status === "success";
var isFailedActionAttempt = (actionAttempt) => actionAttempt.status === "error";
var _a, _parent, _config;
var SeamHttpRequest = class {
  constructor(parent, config) {
    this[_a] = "SeamHttpRequest";
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _config, void 0);
    __privateSet(this, _parent, parent);
    __privateSet(this, _config, config);
  }
  get responseKey() {
    return __privateGet(this, _config).responseKey;
  }
  get url() {
    const { client } = __privateGet(this, _parent);
    const { params } = __privateGet(this, _config);
    const serializer = typeof client.defaults.paramsSerializer === "function" ? client.defaults.paramsSerializer : urlSearchParamsSerializer.serializeUrlSearchParams;
    const origin = getUrlPrefix(client.defaults.baseURL ?? "");
    const pathname = __privateGet(this, _config).path.startsWith("/") ? __privateGet(this, _config).path : `/${__privateGet(this, _config).path}`;
    const path = params == null ? pathname : `${pathname}?${serializer(params)}`;
    return new URL(`${origin}${path}`);
  }
  get method() {
    return __privateGet(this, _config).method;
  }
  get body() {
    return __privateGet(this, _config).body;
  }
  async execute() {
    const { client } = __privateGet(this, _parent);
    const response = await client.request({
      url: __privateGet(this, _config).path,
      method: __privateGet(this, _config).method,
      data: __privateGet(this, _config).body,
      params: __privateGet(this, _config).params
    });
    if (this.responseKey === void 0) {
      return void 0;
    }
    const data = response.data[this.responseKey];
    if (this.responseKey === "action_attempt") {
      const waitForActionAttempt = __privateGet(this, _config).options?.waitForActionAttempt ?? __privateGet(this, _parent).defaults.waitForActionAttempt;
      if (waitForActionAttempt !== false) {
        return await resolveActionAttempt(
          data,
          SeamHttpActionAttempts.fromClient(client, {
            ...__privateGet(this, _parent).defaults,
            waitForActionAttempt: false
          }),
          typeof waitForActionAttempt === "boolean" ? {} : waitForActionAttempt
        );
      }
    }
    return data;
  }
  async then(onfulfilled, onrejected) {
    return await this.execute().then(onfulfilled, onrejected);
  }
  async catch(onrejected) {
    return await this.execute().catch(onrejected);
  }
  async finally(onfinally) {
    return await this.execute().finally(onfinally);
  }
};
_a = Symbol.toStringTag;
_parent = new WeakMap();
_config = new WeakMap();
var getUrlPrefix = (input) => {
  if (URL.canParse(input)) {
    const url = new URL(input).toString();
    if (url.endsWith("/"))
      return url.slice(0, -1);
    return url;
  }
  if (globalThis.location != null) {
    const pathname = input.startsWith("/") ? input : `/${input}`;
    return new URL(`${globalThis.location.origin}${pathname}`).toString();
  }
  throw new Error(
    `Cannot resolve origin from ${input} in a non-browser environment`
  );
};

// src/lib/seam/connect/routes/client-sessions.ts
var SeamHttpClientSessions = class _SeamHttpClientSessions {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = _SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpClientSessions.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpClientSessions(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = _SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/client_sessions/create",
      method: "post",
      body,
      responseKey: "client_session"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/client_sessions/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/client_sessions/get",
      method: "post",
      body,
      responseKey: "client_session"
    });
  }
  getOrCreate(body) {
    return new SeamHttpRequest(this, {
      path: "/client_sessions/get_or_create",
      method: "post",
      body,
      responseKey: "client_session"
    });
  }
  grantAccess(body) {
    return new SeamHttpRequest(this, {
      path: "/client_sessions/grant_access",
      method: "post",
      body,
      responseKey: "client_session"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/client_sessions/list",
      method: "post",
      body,
      responseKey: "client_sessions"
    });
  }
  revoke(body) {
    return new SeamHttpRequest(this, {
      path: "/client_sessions/revoke",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/access-codes-unmanaged.ts
var SeamHttpAccessCodesUnmanaged = class _SeamHttpAccessCodesUnmanaged {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessCodesUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodesUnmanaged(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  convertToManaged(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/unmanaged/convert_to_managed",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/unmanaged/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/unmanaged/get",
      method: "post",
      body,
      responseKey: "access_code"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/unmanaged/list",
      method: "post",
      body,
      responseKey: "access_codes"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/unmanaged/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/access-codes.ts
var SeamHttpAccessCodes = class _SeamHttpAccessCodes {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAccessCodes.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAccessCodes(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get unmanaged() {
    return SeamHttpAccessCodesUnmanaged.fromClient(this.client, this.defaults);
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/create",
      method: "post",
      body,
      responseKey: "access_code"
    });
  }
  createMultiple(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/create_multiple",
      method: "post",
      body,
      responseKey: "access_codes"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  generateCode(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/generate_code",
      method: "post",
      body,
      responseKey: "generated_code"
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/get",
      method: "post",
      body,
      responseKey: "access_code"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/list",
      method: "post",
      body,
      responseKey: "access_codes"
    });
  }
  pullBackupAccessCode(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/pull_backup_access_code",
      method: "post",
      body,
      responseKey: "backup_access_code"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/access_codes/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/acs-access-groups.ts
var SeamHttpAcsAccessGroups = class _SeamHttpAcsAccessGroups {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsAccessGroups.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsAccessGroups(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  addUser(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/access_groups/add_user",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/access_groups/get",
      method: "post",
      body,
      responseKey: "acs_access_group"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/access_groups/list",
      method: "post",
      body,
      responseKey: "acs_access_groups"
    });
  }
  listUsers(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/access_groups/list_users",
      method: "post",
      body,
      responseKey: "acs_users"
    });
  }
  removeUser(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/access_groups/remove_user",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/acs-credential-pools.ts
var SeamHttpAcsCredentialPools = class _SeamHttpAcsCredentialPools {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentialPools.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialPools(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credential_pools/list",
      method: "post",
      body,
      responseKey: "acs_credential_pools"
    });
  }
};

// src/lib/seam/connect/routes/acs-credential-provisioning-automations.ts
var SeamHttpAcsCredentialProvisioningAutomations = class _SeamHttpAcsCredentialProvisioningAutomations {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentialProvisioningAutomations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentialProvisioningAutomations(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  launch(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credential_provisioning_automations/launch",
      method: "post",
      body,
      responseKey: "acs_credential_provisioning_automation"
    });
  }
};

// src/lib/seam/connect/routes/acs-credentials.ts
var SeamHttpAcsCredentials = class _SeamHttpAcsCredentials {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsCredentials.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsCredentials(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  assign(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credentials/assign",
      method: "post",
      body,
      responseKey: "acs_credential"
    });
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credentials/create",
      method: "post",
      body,
      responseKey: "acs_credential"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credentials/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credentials/get",
      method: "post",
      body,
      responseKey: "acs_credential"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credentials/list",
      method: "post",
      body,
      responseKey: "acs_credentials"
    });
  }
  unassign(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credentials/unassign",
      method: "post",
      body,
      responseKey: "acs_credential"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/credentials/update",
      method: "post",
      body,
      responseKey: "acs_credential"
    });
  }
};

// src/lib/seam/connect/routes/acs-entrances.ts
var SeamHttpAcsEntrances = class _SeamHttpAcsEntrances {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsEntrances.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsEntrances(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/entrances/get",
      method: "post",
      body,
      responseKey: "acs_entrance"
    });
  }
  grantAccess(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/entrances/grant_access",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/entrances/list",
      method: "post",
      body,
      responseKey: "acs_entrances"
    });
  }
  listCredentialsWithAccess(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/entrances/list_credentials_with_access",
      method: "post",
      body,
      responseKey: "acs_credentials"
    });
  }
};

// src/lib/seam/connect/routes/acs-systems.ts
var SeamHttpAcsSystems = class _SeamHttpAcsSystems {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsSystems.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsSystems(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/systems/get",
      method: "post",
      body,
      responseKey: "acs_system"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/systems/list",
      method: "post",
      body,
      responseKey: "acs_systems"
    });
  }
};

// src/lib/seam/connect/routes/acs-users.ts
var SeamHttpAcsUsers = class _SeamHttpAcsUsers {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcsUsers.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcsUsers(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  addToAccessGroup(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/add_to_access_group",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/create",
      method: "post",
      body,
      responseKey: "acs_user"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/get",
      method: "post",
      body,
      responseKey: "acs_user"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/list",
      method: "post",
      body,
      responseKey: "acs_users"
    });
  }
  listAccessibleEntrances(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/list_accessible_entrances",
      method: "post",
      body,
      responseKey: "acs_entrances"
    });
  }
  removeFromAccessGroup(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/remove_from_access_group",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  revokeAccessToAllEntrances(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/revoke_access_to_all_entrances",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  suspend(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/suspend",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  unsuspend(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/unsuspend",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/acs/users/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/acs.ts
var SeamHttpAcs = class _SeamHttpAcs {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpAcs.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpAcs(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get accessGroups() {
    return SeamHttpAcsAccessGroups.fromClient(this.client, this.defaults);
  }
  get credentialPools() {
    return SeamHttpAcsCredentialPools.fromClient(this.client, this.defaults);
  }
  get credentialProvisioningAutomations() {
    return SeamHttpAcsCredentialProvisioningAutomations.fromClient(
      this.client,
      this.defaults
    );
  }
  get credentials() {
    return SeamHttpAcsCredentials.fromClient(this.client, this.defaults);
  }
  get entrances() {
    return SeamHttpAcsEntrances.fromClient(this.client, this.defaults);
  }
  get systems() {
    return SeamHttpAcsSystems.fromClient(this.client, this.defaults);
  }
  get users() {
    return SeamHttpAcsUsers.fromClient(this.client, this.defaults);
  }
};

// src/lib/seam/connect/routes/action-attempts.ts
var SeamHttpActionAttempts = class _SeamHttpActionAttempts {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpActionAttempts.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpActionAttempts(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/action_attempts/get",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/action_attempts/list",
      method: "post",
      body,
      responseKey: "action_attempts"
    });
  }
};

// src/lib/seam/connect/routes/connect-webviews.ts
var SeamHttpConnectWebviews = class _SeamHttpConnectWebviews {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpConnectWebviews.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpConnectWebviews(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/connect_webviews/create",
      method: "post",
      body,
      responseKey: "connect_webview"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/connect_webviews/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/connect_webviews/get",
      method: "post",
      body,
      responseKey: "connect_webview"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/connect_webviews/list",
      method: "post",
      body,
      responseKey: "connect_webviews"
    });
  }
  view(params) {
    return new SeamHttpRequest(this, {
      path: "/connect_webviews/view",
      method: "get",
      params,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/connected-accounts.ts
var SeamHttpConnectedAccounts = class _SeamHttpConnectedAccounts {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpConnectedAccounts.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpConnectedAccounts(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/connected_accounts/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/connected_accounts/get",
      method: "post",
      body,
      responseKey: "connected_account"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/connected_accounts/list",
      method: "post",
      body,
      responseKey: "connected_accounts"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/connected_accounts/update",
      method: "post",
      body,
      responseKey: "connected_account"
    });
  }
};

// src/lib/seam/connect/routes/devices-simulate.ts
var SeamHttpDevicesSimulate = class _SeamHttpDevicesSimulate {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevicesSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesSimulate(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  remove(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/simulate/remove",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/devices-unmanaged.ts
var SeamHttpDevicesUnmanaged = class _SeamHttpDevicesUnmanaged {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevicesUnmanaged.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevicesUnmanaged(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/unmanaged/get",
      method: "post",
      body,
      responseKey: "device"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/unmanaged/list",
      method: "post",
      body,
      responseKey: "devices"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/unmanaged/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/devices.ts
var SeamHttpDevices = class _SeamHttpDevices {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpDevices.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpDevices(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get unmanaged() {
    return SeamHttpDevicesUnmanaged.fromClient(this.client, this.defaults);
  }
  get simulate() {
    return SeamHttpDevicesSimulate.fromClient(this.client, this.defaults);
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/get",
      method: "post",
      body,
      responseKey: "device"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/list",
      method: "post",
      body,
      responseKey: "devices"
    });
  }
  listDeviceProviders(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/list_device_providers",
      method: "post",
      body,
      responseKey: "device_providers"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/devices/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/events.ts
var SeamHttpEvents = class _SeamHttpEvents {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpEvents.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpEvents(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/events/get",
      method: "post",
      body,
      responseKey: "event"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/events/list",
      method: "post",
      body,
      responseKey: "events"
    });
  }
};

// src/lib/seam/connect/routes/locks.ts
var SeamHttpLocks = class _SeamHttpLocks {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpLocks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpLocks(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/locks/get",
      method: "post",
      body,
      responseKey: "device"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/locks/list",
      method: "post",
      body,
      responseKey: "devices"
    });
  }
  lockDoor(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/locks/lock_door",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
  unlockDoor(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/locks/unlock_door",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
};

// src/lib/seam/connect/routes/networks.ts
var SeamHttpNetworks = class _SeamHttpNetworks {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNetworks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNetworks(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/networks/get",
      method: "post",
      body,
      responseKey: "network"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/networks/list",
      method: "post",
      body,
      responseKey: "networks"
    });
  }
};

// src/lib/seam/connect/routes/noise-sensors-noise-thresholds.ts
var SeamHttpNoiseSensorsNoiseThresholds = class _SeamHttpNoiseSensorsNoiseThresholds {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNoiseSensorsNoiseThresholds.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensorsNoiseThresholds(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/noise_sensors/noise_thresholds/create",
      method: "post",
      body,
      responseKey: "noise_threshold"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/noise_sensors/noise_thresholds/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/noise_sensors/noise_thresholds/get",
      method: "post",
      body,
      responseKey: "noise_threshold"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/noise_sensors/noise_thresholds/list",
      method: "post",
      body,
      responseKey: "noise_thresholds"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/noise_sensors/noise_thresholds/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/noise-sensors.ts
var SeamHttpNoiseSensors = class _SeamHttpNoiseSensors {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpNoiseSensors.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpNoiseSensors(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get noiseThresholds() {
    return SeamHttpNoiseSensorsNoiseThresholds.fromClient(
      this.client,
      this.defaults
    );
  }
};

// src/lib/seam/connect/routes/phones-simulate.ts
var SeamHttpPhonesSimulate = class _SeamHttpPhonesSimulate {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpPhonesSimulate.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpPhonesSimulate(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  createSandboxPhone(body) {
    return new SeamHttpRequest(this, {
      path: "/phones/simulate/create_sandbox_phone",
      method: "post",
      body,
      responseKey: "phone"
    });
  }
};

// src/lib/seam/connect/routes/phones.ts
var SeamHttpPhones = class _SeamHttpPhones {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpPhones.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpPhones(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get simulate() {
    return SeamHttpPhonesSimulate.fromClient(this.client, this.defaults);
  }
  deactivate(body) {
    return new SeamHttpRequest(this, {
      path: "/phones/deactivate",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/phones/list",
      method: "post",
      body,
      responseKey: "phones"
    });
  }
};

// src/lib/seam/connect/routes/thermostats-climate-setting-schedules.ts
var SeamHttpThermostatsClimateSettingSchedules = class _SeamHttpThermostatsClimateSettingSchedules {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostatsClimateSettingSchedules.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostatsClimateSettingSchedules(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/climate_setting_schedules/create",
      method: "post",
      body,
      responseKey: "climate_setting_schedule"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/climate_setting_schedules/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/climate_setting_schedules/get",
      method: "post",
      body,
      responseKey: "climate_setting_schedule"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/climate_setting_schedules/list",
      method: "post",
      body,
      responseKey: "climate_setting_schedules"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/climate_setting_schedules/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/thermostats.ts
var SeamHttpThermostats = class _SeamHttpThermostats {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpThermostats.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpThermostats(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get climateSettingSchedules() {
    return SeamHttpThermostatsClimateSettingSchedules.fromClient(
      this.client,
      this.defaults
    );
  }
  cool(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/cool",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/get",
      method: "post",
      body,
      responseKey: "thermostat"
    });
  }
  heat(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/heat",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
  heatCool(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/heat_cool",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/list",
      method: "post",
      body,
      responseKey: "thermostats"
    });
  }
  off(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/off",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
  setFanMode(body, options = {}) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/set_fan_mode",
      method: "post",
      body,
      responseKey: "action_attempt",
      options
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/thermostats/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/user-identities-enrollment-automations.ts
var SeamHttpUserIdentitiesEnrollmentAutomations = class _SeamHttpUserIdentitiesEnrollmentAutomations {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUserIdentitiesEnrollmentAutomations.fromClientSessionToken(
      token,
      options
    );
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentitiesEnrollmentAutomations(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/enrollment_automations/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/enrollment_automations/get",
      method: "post",
      body,
      responseKey: "enrollment_automation"
    });
  }
  launch(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/enrollment_automations/launch",
      method: "post",
      body,
      responseKey: "enrollment_automation"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/enrollment_automations/list",
      method: "post",
      body,
      responseKey: "enrollment_automations"
    });
  }
};

// src/lib/seam/connect/routes/user-identities.ts
var SeamHttpUserIdentities = class _SeamHttpUserIdentities {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpUserIdentities.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpUserIdentities(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get enrollmentAutomations() {
    return SeamHttpUserIdentitiesEnrollmentAutomations.fromClient(
      this.client,
      this.defaults
    );
  }
  addAcsUser(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/add_acs_user",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/create",
      method: "post",
      body,
      responseKey: "user_identity"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/get",
      method: "post",
      body,
      responseKey: "user_identity"
    });
  }
  grantAccessToDevice(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/grant_access_to_device",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/list",
      method: "post",
      body,
      responseKey: "user_identities"
    });
  }
  listAccessibleDevices(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/list_accessible_devices",
      method: "post",
      body,
      responseKey: "accessible_devices"
    });
  }
  listAcsSystems(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/list_acs_systems",
      method: "post",
      body,
      responseKey: "acs_systems"
    });
  }
  listAcsUsers(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/list_acs_users",
      method: "post",
      body,
      responseKey: "acs_users"
    });
  }
  removeAcsUser(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/remove_acs_user",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  revokeAccessToDevice(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/revoke_access_to_device",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/user_identities/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/webhooks.ts
var SeamHttpWebhooks = class _SeamHttpWebhooks {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpWebhooks.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpWebhooks(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/webhooks/create",
      method: "post",
      body,
      responseKey: "webhook"
    });
  }
  delete(body) {
    return new SeamHttpRequest(this, {
      path: "/webhooks/delete",
      method: "post",
      body,
      responseKey: void 0
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/webhooks/get",
      method: "post",
      body,
      responseKey: "webhook"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/webhooks/list",
      method: "post",
      body,
      responseKey: "webhooks"
    });
  }
  update(body) {
    return new SeamHttpRequest(this, {
      path: "/webhooks/update",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/routes/workspaces.ts
var SeamHttpWorkspaces = class _SeamHttpWorkspaces {
  constructor(apiKeyOrOptions = {}) {
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttpWorkspaces.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttpWorkspaces(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  create(body) {
    return new SeamHttpRequest(this, {
      path: "/workspaces/create",
      method: "post",
      body,
      responseKey: "workspace"
    });
  }
  get(body) {
    return new SeamHttpRequest(this, {
      path: "/workspaces/get",
      method: "post",
      body,
      responseKey: "workspace"
    });
  }
  list(body) {
    return new SeamHttpRequest(this, {
      path: "/workspaces/list",
      method: "post",
      body,
      responseKey: "workspaces"
    });
  }
  resetSandbox(body) {
    return new SeamHttpRequest(this, {
      path: "/workspaces/reset_sandbox",
      method: "post",
      body,
      responseKey: void 0
    });
  }
};

// src/lib/seam/connect/seam-http.ts
var _SeamHttp = class _SeamHttp {
  constructor(apiKeyOrOptions = {}) {
    this.ltsVersion = seamApiLtsVersion;
    const options = parseOptions(apiKeyOrOptions);
    this.client = "client" in options ? options.client : createClient(options);
    this.defaults = limitToSeamHttpRequestOptions(options);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpOptionsWithClient(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing client");
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromApiKey(apiKey, options = {}) {
    const constructorOptions = { ...options, apiKey };
    if (!isSeamHttpOptionsWithApiKey(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing apiKey");
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromClientSessionToken(clientSessionToken, options = {}) {
    const constructorOptions = { ...options, clientSessionToken };
    if (!isSeamHttpOptionsWithClientSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError("Missing clientSessionToken");
    }
    return new _SeamHttp(constructorOptions);
  }
  static async fromPublishableKey(publishableKey, userIdentifierKey, options = {}) {
    warnOnInsecureuserIdentifierKey(userIdentifierKey);
    const clientOptions = parseOptions({ ...options, publishableKey });
    if (isSeamHttpOptionsWithClient(clientOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "The client option cannot be used with SeamHttp.fromPublishableKey"
      );
    }
    const client = createClient(clientOptions);
    const clientSessions = SeamHttpClientSessions.fromClient(client);
    const { token } = await clientSessions.getOrCreate({
      user_identifier_key: userIdentifierKey
    });
    return _SeamHttp.fromClientSessionToken(token, options);
  }
  static fromConsoleSessionToken(consoleSessionToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken, workspaceId };
    if (!isSeamHttpOptionsWithConsoleSessionToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing consoleSessionToken or workspaceId"
      );
    }
    return new _SeamHttp(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, workspaceId, options = {}) {
    const constructorOptions = { ...options, personalAccessToken, workspaceId };
    if (!isSeamHttpOptionsWithPersonalAccessToken(constructorOptions)) {
      throw new SeamHttpInvalidOptionsError(
        "Missing personalAccessToken or workspaceId"
      );
    }
    return new _SeamHttp(constructorOptions);
  }
  async updateClientSessionToken(clientSessionToken) {
    const { headers } = this.client.defaults;
    const authHeaders = getAuthHeadersForClientSessionToken({
      clientSessionToken
    });
    for (const key of Object.keys(authHeaders)) {
      if (headers[key] == null) {
        throw new Error(
          "Cannot update a clientSessionToken on a client created without a clientSessionToken"
        );
      }
    }
    this.client.defaults.headers = { ...headers, ...authHeaders };
    const clientSessions = SeamHttpClientSessions.fromClient(this.client);
    await clientSessions.get();
  }
  get accessCodes() {
    return SeamHttpAccessCodes.fromClient(this.client, this.defaults);
  }
  get acs() {
    return SeamHttpAcs.fromClient(this.client, this.defaults);
  }
  get actionAttempts() {
    return SeamHttpActionAttempts.fromClient(this.client, this.defaults);
  }
  get clientSessions() {
    return SeamHttpClientSessions.fromClient(this.client, this.defaults);
  }
  get connectedAccounts() {
    return SeamHttpConnectedAccounts.fromClient(this.client, this.defaults);
  }
  get connectWebviews() {
    return SeamHttpConnectWebviews.fromClient(this.client, this.defaults);
  }
  get devices() {
    return SeamHttpDevices.fromClient(this.client, this.defaults);
  }
  get events() {
    return SeamHttpEvents.fromClient(this.client, this.defaults);
  }
  get locks() {
    return SeamHttpLocks.fromClient(this.client, this.defaults);
  }
  get networks() {
    return SeamHttpNetworks.fromClient(this.client, this.defaults);
  }
  get noiseSensors() {
    return SeamHttpNoiseSensors.fromClient(this.client, this.defaults);
  }
  get phones() {
    return SeamHttpPhones.fromClient(this.client, this.defaults);
  }
  get thermostats() {
    return SeamHttpThermostats.fromClient(this.client, this.defaults);
  }
  get userIdentities() {
    return SeamHttpUserIdentities.fromClient(this.client, this.defaults);
  }
  get webhooks() {
    return SeamHttpWebhooks.fromClient(this.client, this.defaults);
  }
  get workspaces() {
    return SeamHttpWorkspaces.fromClient(this.client, this.defaults);
  }
};
_SeamHttp.ltsVersion = seamApiLtsVersion;
var SeamHttp = _SeamHttp;

// src/lib/seam/connect/seam-http-multi-workspace.ts
var SeamHttpMultiWorkspace = class _SeamHttpMultiWorkspace {
  constructor(options) {
    const opts = parseOptions(options);
    this.client = "client" in opts ? opts.client : createClient(opts);
    this.defaults = limitToSeamHttpRequestOptions(opts);
  }
  static fromClient(client, options = {}) {
    const constructorOptions = { ...options, client };
    if (!isSeamHttpMultiWorkspaceOptionsWithClient(constructorOptions)) {
      throw new SeamHttpMultiWorkspaceInvalidOptionsError("Missing client");
    }
    return new _SeamHttpMultiWorkspace(constructorOptions);
  }
  static fromConsoleSessionToken(consoleSessionToken, options = {}) {
    const constructorOptions = { ...options, consoleSessionToken };
    if (!isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken(
      constructorOptions
    )) {
      throw new SeamHttpMultiWorkspaceInvalidOptionsError(
        "Missing consoleSessionToken"
      );
    }
    return new _SeamHttpMultiWorkspace(constructorOptions);
  }
  static fromPersonalAccessToken(personalAccessToken, options = {}) {
    const constructorOptions = { ...options, personalAccessToken };
    if (!isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken(
      constructorOptions
    )) {
      throw new SeamHttpMultiWorkspaceInvalidOptionsError(
        "Missing personalAccessToken"
      );
    }
    return new _SeamHttpMultiWorkspace(constructorOptions);
  }
  get workspaces() {
    return SeamHttpWorkspaces.fromClient(this.client, this.defaults);
  }
};

exports.SeamActionAttemptError = SeamActionAttemptError;
exports.SeamActionAttemptFailedError = SeamActionAttemptFailedError;
exports.SeamActionAttemptTimeoutError = SeamActionAttemptTimeoutError;
exports.SeamHttp = SeamHttp;
exports.SeamHttpAccessCodes = SeamHttpAccessCodes;
exports.SeamHttpAccessCodesUnmanaged = SeamHttpAccessCodesUnmanaged;
exports.SeamHttpAcs = SeamHttpAcs;
exports.SeamHttpAcsAccessGroups = SeamHttpAcsAccessGroups;
exports.SeamHttpAcsCredentialPools = SeamHttpAcsCredentialPools;
exports.SeamHttpAcsCredentialProvisioningAutomations = SeamHttpAcsCredentialProvisioningAutomations;
exports.SeamHttpAcsCredentials = SeamHttpAcsCredentials;
exports.SeamHttpAcsEntrances = SeamHttpAcsEntrances;
exports.SeamHttpAcsSystems = SeamHttpAcsSystems;
exports.SeamHttpAcsUsers = SeamHttpAcsUsers;
exports.SeamHttpActionAttempts = SeamHttpActionAttempts;
exports.SeamHttpApiError = SeamHttpApiError;
exports.SeamHttpClientSessions = SeamHttpClientSessions;
exports.SeamHttpConnectWebviews = SeamHttpConnectWebviews;
exports.SeamHttpConnectedAccounts = SeamHttpConnectedAccounts;
exports.SeamHttpDevices = SeamHttpDevices;
exports.SeamHttpDevicesSimulate = SeamHttpDevicesSimulate;
exports.SeamHttpDevicesUnmanaged = SeamHttpDevicesUnmanaged;
exports.SeamHttpEvents = SeamHttpEvents;
exports.SeamHttpInvalidInputError = SeamHttpInvalidInputError;
exports.SeamHttpInvalidOptionsError = SeamHttpInvalidOptionsError;
exports.SeamHttpInvalidTokenError = SeamHttpInvalidTokenError;
exports.SeamHttpLocks = SeamHttpLocks;
exports.SeamHttpMultiWorkspace = SeamHttpMultiWorkspace;
exports.SeamHttpMultiWorkspaceInvalidOptionsError = SeamHttpMultiWorkspaceInvalidOptionsError;
exports.SeamHttpNetworks = SeamHttpNetworks;
exports.SeamHttpNoiseSensors = SeamHttpNoiseSensors;
exports.SeamHttpNoiseSensorsNoiseThresholds = SeamHttpNoiseSensorsNoiseThresholds;
exports.SeamHttpPhones = SeamHttpPhones;
exports.SeamHttpPhonesSimulate = SeamHttpPhonesSimulate;
exports.SeamHttpRequest = SeamHttpRequest;
exports.SeamHttpThermostats = SeamHttpThermostats;
exports.SeamHttpThermostatsClimateSettingSchedules = SeamHttpThermostatsClimateSettingSchedules;
exports.SeamHttpUnauthorizedError = SeamHttpUnauthorizedError;
exports.SeamHttpUserIdentities = SeamHttpUserIdentities;
exports.SeamHttpUserIdentitiesEnrollmentAutomations = SeamHttpUserIdentitiesEnrollmentAutomations;
exports.SeamHttpWebhooks = SeamHttpWebhooks;
exports.SeamHttpWorkspaces = SeamHttpWorkspaces;
exports.errorInterceptor = errorInterceptor;
exports.getOpenapiSchema = getOpenapiSchema;
exports.isApiKey = isApiKey;
exports.isClientSessionToken = isClientSessionToken;
exports.isConsoleSessionToken = isConsoleSessionToken;
exports.isPersonalAccessToken = isPersonalAccessToken;
exports.isPublishableKey = isPublishableKey;
exports.isSeamActionAttemptError = isSeamActionAttemptError;
exports.isSeamActionAttemptFailedError = isSeamActionAttemptFailedError;
exports.isSeamActionAttemptTimeoutError = isSeamActionAttemptTimeoutError;
exports.isSeamHttpApiError = isSeamHttpApiError;
exports.isSeamHttpInvalidInputError = isSeamHttpInvalidInputError;
exports.isSeamHttpMultiWorkspaceOptionsWithClient = isSeamHttpMultiWorkspaceOptionsWithClient;
exports.isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken = isSeamHttpMultiWorkspaceOptionsWithConsoleSessionToken;
exports.isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken = isSeamHttpMultiWorkspaceOptionsWithPersonalAccessToken;
exports.isSeamHttpOptionsWithApiKey = isSeamHttpOptionsWithApiKey;
exports.isSeamHttpOptionsWithClient = isSeamHttpOptionsWithClient;
exports.isSeamHttpOptionsWithClientSessionToken = isSeamHttpOptionsWithClientSessionToken;
exports.isSeamHttpOptionsWithConsoleSessionToken = isSeamHttpOptionsWithConsoleSessionToken;
exports.isSeamHttpOptionsWithPersonalAccessToken = isSeamHttpOptionsWithPersonalAccessToken;
exports.isSeamHttpUnauthorizedError = isSeamHttpUnauthorizedError;
Object.keys(urlSearchParamsSerializer).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return urlSearchParamsSerializer[k]; }
  });
});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=connect.cjs.map