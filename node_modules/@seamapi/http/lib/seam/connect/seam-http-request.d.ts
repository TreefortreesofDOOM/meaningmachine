import type { Method } from 'axios';
import type { Client } from './client.js';
import type { SeamHttpRequestOptions } from './options.js';
interface SeamHttpRequestParent {
    readonly client: Client;
    readonly defaults: Required<SeamHttpRequestOptions>;
}
interface SeamHttpRequestConfig<TResponseKey> {
    readonly path: string;
    readonly method: Method;
    readonly body?: unknown;
    readonly params?: undefined | Record<string, unknown>;
    readonly responseKey: TResponseKey;
    readonly options?: Pick<SeamHttpRequestOptions, 'waitForActionAttempt'>;
}
export declare class SeamHttpRequest<const TResponse, const TResponseKey extends keyof TResponse | undefined> implements Promise<TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined> {
    #private;
    readonly [Symbol.toStringTag]: string;
    constructor(parent: SeamHttpRequestParent, config: SeamHttpRequestConfig<TResponseKey>);
    get responseKey(): TResponseKey;
    get url(): URL;
    get method(): Method;
    get body(): unknown;
    execute(): Promise<TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined>;
    then<TResult1 = TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined, TResult2 = never>(onfulfilled?: ((value: TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined): Promise<(TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined) | TResult>;
    finally(onfinally?: (() => void) | null | undefined): Promise<TResponseKey extends keyof TResponse ? TResponse[TResponseKey] : undefined>;
}
export {};
