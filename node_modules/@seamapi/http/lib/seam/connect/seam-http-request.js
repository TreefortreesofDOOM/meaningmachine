var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SeamHttpRequest_parent, _SeamHttpRequest_config, _a;
import { serializeUrlSearchParams } from '@seamapi/url-search-params-serializer';
import { resolveActionAttempt } from './resolve-action-attempt.js';
import { SeamHttpActionAttempts } from './routes/index.js';
export class SeamHttpRequest {
    constructor(parent, config) {
        this[_a] = 'SeamHttpRequest';
        _SeamHttpRequest_parent.set(this, void 0);
        _SeamHttpRequest_config.set(this, void 0);
        __classPrivateFieldSet(this, _SeamHttpRequest_parent, parent, "f");
        __classPrivateFieldSet(this, _SeamHttpRequest_config, config, "f");
    }
    get responseKey() {
        return __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").responseKey;
    }
    get url() {
        const { client } = __classPrivateFieldGet(this, _SeamHttpRequest_parent, "f");
        const { params } = __classPrivateFieldGet(this, _SeamHttpRequest_config, "f");
        const serializer = typeof client.defaults.paramsSerializer === 'function'
            ? client.defaults.paramsSerializer
            : serializeUrlSearchParams;
        const origin = getUrlPrefix(client.defaults.baseURL ?? '');
        const pathname = __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").path.startsWith('/')
            ? __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").path
            : `/${__classPrivateFieldGet(this, _SeamHttpRequest_config, "f").path}`;
        const path = params == null ? pathname : `${pathname}?${serializer(params)}`;
        return new URL(`${origin}${path}`);
    }
    get method() {
        return __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").method;
    }
    get body() {
        return __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").body;
    }
    async execute() {
        const { client } = __classPrivateFieldGet(this, _SeamHttpRequest_parent, "f");
        const response = await client.request({
            url: __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").path,
            method: __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").method,
            data: __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").body,
            params: __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").params,
        });
        if (this.responseKey === undefined) {
            return undefined;
        }
        const data = response.data[this.responseKey];
        if (this.responseKey === 'action_attempt') {
            const waitForActionAttempt = __classPrivateFieldGet(this, _SeamHttpRequest_config, "f").options?.waitForActionAttempt ??
                __classPrivateFieldGet(this, _SeamHttpRequest_parent, "f").defaults.waitForActionAttempt;
            if (waitForActionAttempt !== false) {
                return await resolveActionAttempt(data, SeamHttpActionAttempts.fromClient(client, {
                    ...__classPrivateFieldGet(this, _SeamHttpRequest_parent, "f").defaults,
                    waitForActionAttempt: false,
                }), typeof waitForActionAttempt === 'boolean' ? {} : waitForActionAttempt);
            }
        }
        return data;
    }
    async then(onfulfilled, onrejected) {
        return await this.execute().then(onfulfilled, onrejected);
    }
    async catch(onrejected) {
        return await this.execute().catch(onrejected);
    }
    async finally(onfinally) {
        return await this.execute().finally(onfinally);
    }
}
_SeamHttpRequest_parent = new WeakMap(), _SeamHttpRequest_config = new WeakMap(), _a = Symbol.toStringTag;
const getUrlPrefix = (input) => {
    if (URL.canParse(input)) {
        const url = new URL(input).toString();
        if (url.endsWith('/'))
            return url.slice(0, -1);
        return url;
    }
    if (globalThis.location != null) {
        const pathname = input.startsWith('/') ? input : `/${input}`;
        return new URL(`${globalThis.location.origin}${pathname}`).toString();
    }
    throw new Error(`Cannot resolve origin from ${input} in a non-browser environment`);
};
//# sourceMappingURL=seam-http-request.js.map