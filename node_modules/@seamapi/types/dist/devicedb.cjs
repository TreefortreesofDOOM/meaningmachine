'use strict';

var zod = require('zod');

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/lib/seam/devicedb/models/index.ts
var models_exports = {};
__export(models_exports, {
  base_device_model_v1: () => base_device_model_v1,
  device_capability_flags: () => device_capability_flags,
  device_category: () => device_category,
  device_connection_type: () => device_connection_type,
  device_model_category_specific_properties: () => device_model_category_specific_properties,
  device_model_v1: () => device_model_v1,
  image_reference: () => image_reference,
  manufacturer: () => manufacturer,
  manufacturer_annotation: () => manufacturer_annotation,
  manufacturer_annotation_code: () => manufacturer_annotation_code,
  manufacturer_integration_support_level: () => manufacturer_integration_support_level,
  thermostat: () => thermostat
});
var device_capability_flags = zod.z.object({
  can_remotely_unlock: zod.z.boolean(),
  can_remotely_lock: zod.z.boolean(),
  can_program_offline_access_codes: zod.z.boolean(),
  can_program_online_access_codes: zod.z.boolean()
}).partial();
var device_model_capability_flags_map = {
  can_remotely_lock: zod.z.literal(true),
  can_remotely_unlock: zod.z.literal(true),
  can_program_offline_access_codes: zod.z.literal(true),
  can_program_online_access_codes: zod.z.literal(true)
};
var device_model_capability_flags = zod.z.object(device_model_capability_flags_map).partial();
var hardware = zod.z.object({
  has_physical_key: zod.z.boolean()
}).partial();
var image_reference = zod.z.object({
  url: zod.z.string().url(),
  width: zod.z.number(),
  height: zod.z.number()
});
var manufacturer_integration_support_level = zod.z.enum([
  "stable",
  "beta",
  "planned",
  "unsupported",
  "inquire"
]);
var manufacturer_annotation_code = zod.z.enum(["subscription_required"]);
var manufacturer_annotation = zod.z.object({
  annotation_code: manufacturer_annotation_code,
  message: zod.z.string().trim().nonempty()
});
var manufacturer = zod.z.object({
  manufacturer_id: zod.z.string().uuid(),
  display_name: zod.z.string(),
  logo: image_reference.optional(),
  /** @deprecated */
  integration: manufacturer_integration_support_level,
  integration_support_level: manufacturer_integration_support_level,
  is_connect_webview_supported: zod.z.boolean(),
  requires_seam_support_to_add_account: zod.z.boolean(),
  device_model_count: zod.z.number(),
  annotations: zod.z.array(manufacturer_annotation)
});

// src/lib/seam/devicedb/models/device-model.ts
var device_category = zod.z.enum([
  "smartlock",
  "sensor",
  "thermostat",
  "relay",
  "intercom",
  "accessory"
]);
var device_connection_type = zod.z.enum([
  "wifi",
  "zwave",
  "zigbee",
  "unknown"
]);
var smartlock = zod.z.object({
  main_category: zod.z.literal(device_category.enum.smartlock),
  physical_properties: zod.z.object({
    lock_type: zod.z.enum([
      "deadbolt",
      "lever",
      "mortise",
      "lockbox",
      "cylinder",
      "padlock",
      "locker",
      "unknown"
    ]),
    has_physical_key: zod.z.boolean(),
    has_camera: zod.z.boolean()
  }),
  software_features: zod.z.object({
    can_remotely_unlock: zod.z.boolean(),
    can_program_access_codes: zod.z.boolean(),
    can_program_access_schedules: zod.z.boolean(),
    can_program_access_codes_offline: zod.z.boolean()
  })
}).merge(
  device_model_capability_flags.pick({
    can_remotely_lock: true,
    can_remotely_unlock: true,
    can_program_offline_access_codes: true,
    can_program_online_access_codes: true
  })
);
var sensor = zod.z.object({
  main_category: zod.z.literal(device_category.enum.sensor),
  physical_properties: zod.z.object({
    has_noise_sensor: zod.z.boolean(),
    has_humidity_sensor: zod.z.boolean(),
    has_temperature_sensor: zod.z.boolean(),
    has_occupancy_detection: zod.z.boolean()
  })
});
var thermostat = zod.z.object({
  main_category: zod.z.literal(device_category.enum.thermostat),
  physical_properties: zod.z.object({
    available_modes: zod.z.enum(["heat", "cool", "fan", "eco"]).array(),
    is_heat_pump_compatible: zod.z.boolean(),
    has_occupancy_detection: zod.z.boolean(),
    supports_demand_response: zod.z.boolean(),
    has_humidity_sensor: zod.z.boolean(),
    has_temperature_sensor: zod.z.boolean(),
    supports_emergency_heating_mode: zod.z.boolean()
  }),
  software_features: zod.z.object({
    can_program_climate_schedules: zod.z.boolean()
  })
});
var relay = zod.z.object({
  main_category: zod.z.literal(device_category.enum.relay)
});
var intercom = zod.z.object({
  main_category: zod.z.literal(device_category.enum.intercom),
  physical_properties: zod.z.object({
    has_camera: zod.z.boolean(),
    has_rfid_reader: zod.z.boolean().default(false),
    has_nfc_reader: zod.z.boolean().default(false),
    has_wiegand_interface: zod.z.boolean().default(false)
  }),
  software_features: zod.z.object({
    can_remotely_unlock: zod.z.boolean(),
    can_program_access_codes: zod.z.boolean(),
    can_unlock_with_face_recognition: zod.z.boolean().default(false),
    supports_onvif: zod.z.boolean().default(false)
  })
});
var accessory = zod.z.object({
  main_category: zod.z.literal(device_category.enum.accessory)
});
var device_model_category_specific_properties = zod.z.discriminatedUnion(
  "main_category",
  [smartlock, sensor, thermostat, relay, intercom, accessory]
);
var base_device_model_v1 = zod.z.object({
  device_model_id: zod.z.string().uuid(),
  manufacturer: manufacturer.omit({
    device_model_count: true
  }),
  is_device_supported: zod.z.boolean(),
  display_name: zod.z.string(),
  description: zod.z.string(),
  product_url: zod.z.string().optional(),
  main_connection_type: device_connection_type,
  hardware,
  aesthetic_variants: zod.z.object({
    slug: zod.z.string(),
    display_name: zod.z.string(),
    primary_color_hex: zod.z.string().optional(),
    manufacturer_sku: zod.z.string().optional(),
    front_image: image_reference.optional(),
    back_image: image_reference.optional(),
    images: image_reference.array()
  }).array(),
  power_sources: zod.z.enum([
    "battery",
    "hardwired",
    "mechanical_harvesting",
    "wireless",
    "ethernet"
  ]).array()
});
var device_model_v1 = base_device_model_v1.and(
  device_model_category_specific_properties
);
var dot_path = zod.z.string().regex(/^([a-z])[a-z_.]*[a-z]+$/);
var routes = {
  "/api/v1/device_models/get": {
    auth: "publishable_key",
    methods: ["GET", "OPTIONS"],
    queryParams: zod.z.object({
      device_model_id: zod.z.string().uuid()
    }),
    jsonResponse: zod.z.object({
      device_model: device_model_v1
    })
  },
  "/api/v1/device_models/list": {
    auth: "publishable_key",
    methods: ["GET", "OPTIONS"],
    queryParams: zod.z.object({
      main_category: device_category.optional(),
      manufacturer_id: zod.z.string().uuid().optional(),
      manufacturer_ids: zod.z.string().uuid().array().optional(),
      /** @deprecated */
      integration_status: manufacturer.shape.integration.optional(),
      integration_support_levels: zod.z.array(manufacturer_integration_support_level).optional(),
      text_search: zod.z.string().optional(),
      include_if: zod.z.array(dot_path).optional(),
      exclude_if: zod.z.array(dot_path).optional()
    }),
    jsonResponse: zod.z.object({
      device_models: device_model_v1.array()
    })
  },
  "/api/v1/manufacturers/get": {
    auth: "publishable_key",
    methods: ["GET", "OPTIONS"],
    queryParams: zod.z.object({
      manufacturer_id: zod.z.string().uuid()
    }),
    jsonResponse: zod.z.object({
      manufacturer
    })
  },
  "/api/v1/manufacturers/list": {
    auth: "publishable_key",
    methods: ["GET", "OPTIONS"],
    queryParams: zod.z.object({
      /** @deprecated */
      integration_status: manufacturer.shape.integration.optional(),
      integration_support_levels: zod.z.array(manufacturer_integration_support_level).optional(),
      liqe_query: zod.z.string().optional()
    }),
    jsonResponse: zod.z.object({
      manufacturers: manufacturer.array()
    })
  }
};

exports.routes = routes;
exports.schemas = models_exports;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=devicedb.cjs.map